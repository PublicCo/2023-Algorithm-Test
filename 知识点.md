## 第一章

算法是一系列解决问题的明确指令

* 输入符合规范
* 运行时间有限
* 输出正确

算法要求满足如下特征：

* 输入为0个或有限个以提供初始条件
* 输出至少一个正确的结果
* 算法的结果要有确定性

算法的特点：

* 有输入
* 有输出
* 确定性（输出确定）
* 有穷性
* 可行性

## 第二章

渐进符号：On是小于等于，Ωn是大于等于，Θn是同等级（在n趋于无穷时）

最好：输入数量级为n，但你可以想办法让输入的序列算法处理起来最容易

最差：输入数量级为n，且输入让算法跑的最久

平均：每种输入都是1/n，求时间加权平均（或者说是随机输入的时间复杂度，不是最好和最坏取平均）

如何求递归的函数复杂度？

* 先写出运行次数的递推关系
* 再写出运行次数的初态
* 最后用数列求解

分析方法：洛必达，用定义（Θn可以通过夹逼来证明）

判断增长阶数

## 第三章

brute-force：暴力法求解（Just Do It！）

简单直接求解

* 优点：广泛使用，简单
* 缺点：时间太长
* 通常用来作为算法优化比较依据

比较经典的蛮力法求解：

* 选择排序（或者冒泡排序）：On^2
* 最小字符串匹配：O（mn）：父字符串一个字符一个字符跳过，和子字符串比较
* 旅行商问题（找到不重复经过每个城市走一圈最短路径：O（n！））
* 背包问题：遍历解空间树的每一种解法，即遍历物品的所有子集：O（2^n)
* 最优分配：n个东西给n个人，遍历所有可能的分配方式，O（n！）（就是排列问题）

## 第五章

减治法：利用一个问题在给定实例解和较小实例解之间的关系来递归求解此问题

简单来说就是找到M(n)=M(n-1)+f(n),当f(n)的复杂度可以接受时问题得以优化

可以分为自底向上和自顶向下

三种方法：

* 减常量
* 减常因子（比如二分）
* 减可变规模

减常量：

* 插入排序：最差n方最优n平均四分之n方
* 拓扑排序：判断有向无环依赖dfs：O（E+V），排序过程依赖dfs：O（E+V）

减常因子（通常就是二分）：

* 二分搜索：最优1最差logn
* 假币问题（三分搜索）
* 俄式乘法：n*m=(n/2)\* 2m

减可变规模：

* 欧几里得（每次n减去的规模都不一样）

平滑法则：离散的点可以判断连续的时间复杂度

## 第六章

分治法：将一个问题拆成几个规模较小的小问题（可以退化成减治法）

简单来说就是F(n)=aF(n/b)+f(n),a和b可以接受的情况下算法得到优化

三步走：

* 分解：把问题拆成几个小问题
* 处理：把小问题以递归的方式解决
* 合成：将几个小问题合起来解决较大规模的原问题

主定理：对于F(n)=aF(n/b)+f(n),f(n)=O(n^d)

* F(n)=O(n^d), if a<b^d
* F(n)=O(n^dlogn), if a= b^d
* F(n)=O(n^logb(a)), if a>b^d

比较经典的分治算法：

* merge sort：最差nlogn(f(n)=n-1)，最好也是nlogn（f(n)=n/2)
* quick sort: 最差On^2（每次交换右指针不变，左指针都遍历一次整个数组，整个数组正好是有序的），最好nlogn
* 二分查找
* n位大整数乘法：将两个数分为AB和CD，则X*Y = A\*C\*10^n +((A+B)(C+D)-AC-BD)+BD,这样从做四次乘法变成做三次乘法，F(n)=3F(n/2)
* stressan算法：把矩阵拆开相乘，和大整数相似也是可以减少乘法次数

## 第七章

变治法：通过改变问题来化简问题

两步走：

* 变：将问题变得容易
* 治：求解更容易的问题

化简有三种方式：

* 实例化简
* 改变表现
* 问题化简

具体算法：

* 实例化简

  * 先排序再进行操作（排序复杂度是nlogn，对于n^2以上问题有优化空间）

    * 搜索所有指定的key

    * 多元一次方程消去：由于化一的过程可能乘的系数过大，因此建议第一行的第一列系数最大，第二行的第二列的系数最大，这样乘的系数就可以小于1不会溢出；同时如果i行i列为0就将一个不为零的行交换过去
      * 复杂度：O（n^3(消去)+n^2(求解x))

  * 堆排序：排序前先建堆（最大堆或最小堆）再排序（每次取出最大值，从堆中删除再维护堆）

* 改变表现

  * horner化简算法：把多项式加法改成乘系数加下一个系数

* 问题化简

  * 把三点位置问题化为行列式
  * 把有限制最大值求解化为线性规划
    * 0-1离散背包问题（整数线性规划）
  * 将puzzle转为图问题（决策树问题）

## 第八章

搜索空间标识方式（解空间标识）：用线性表标识、显示图表示、隐式图表示

* 一个问题的解可以用解向量表示
* 所有满足显式约束的解向量构成解空间
* 解空间树通过树状形式标识了每个解的构成形式

回溯法：

* 优点：搜索解空间树时动态产生问题解空间，每次只显式保存一条路径，行不通/已经到叶节点时就返回
* 效率分析：取决于剪枝函数的效率和减去分支的效率。当回溯法根据剪枝函数停止向前时权衡减去的分支个数与剪枝计算的消耗

分支限界：可以通过广度优先或者优先队列进行下一节点的拓展（因此采用**队列**进行操作）

优先队列：在活结点处选择优先队列中最优先的节点进行拓展。没有优先队列就退化到bfs

### 回溯法和穷举法的联系与区别

* 联系：都是基于试探搜索方法
* 区别：
  * 穷举法要将某个解的全部可能全生成完才停止
  * 回溯法则是当已知这个解的某一部分已经不满足要求时就放弃后续的生成转到另一个解

### 回溯法和分支限界法区别

* 求解目标不同：回溯搜所有解，分支限界搜一个解
* 搜索方法不同：回溯dfs，分支限界bfs
* 拓展节点拓展方式不同：分支限界一个活结点只能拓一次，一次全拓展完；回溯拓展多次，一次拓展一个
* 存储空间要求不同：bfs空间要求比dfs要大

## 第九章

MDP：多阶段决策问题，在每个阶段都要做出决策，这个决策会影响下一个阶段的问题

DP：单阶段决策

马尔科夫性：某阶段状态给定后之前的路径不影响之后的结果

DP求解步骤：

1. 找到最优解的性质，并刻画其基本特征
2. 递归定义最优解法（写出dp方程）
3. 自底向上或者自顶向下找到最优解
4. 记录最优解信息，找到求解路径

DP有效要求：

* 最优子结构：最优解的子结构也是最优解
* 重叠子问题：递归算法需要不断求解某个子问题时可以用dp记录来减少求解次数

DP算法：

* 斐波那契数列
* 算组合数
* 最长相同字符串
* 动态数组乘法分配
* 0-1背包
* 多源选择
* warshall闭包
* Floyd多源最短路径

## 第十章

贪心算法：每一步都选择局部最优，最终得到全局最优

* 要证明局部最优能得到全局最优
  * 具有贪心选择性质
  * 具有最优子结构性质

算法：

* 分数背包问题（选好最优）
* Dijkstra算法（单源最短路径）
* kruskal算法（最小路径树的选边+法）
* Prim算法（最小路径树的选点法）

### DP和贪心区别

|          | DP                   | 贪心                                         |
| -------- | -------------------- | -------------------------------------------- |
| 子问题   | 每步依赖于子问题的解 | 仅做出当前状态下最好的选择，不考虑子问题的解 |
| 求解方式 | 通常自底向上         | 通常自顶向下，每次选择当前最优解             |

